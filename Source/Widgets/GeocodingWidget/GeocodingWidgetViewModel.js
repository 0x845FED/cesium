/*global define*/
define([
        '../../Core/Cartesian2',
        '../../Core/Cartesian3',
        '../../Core/Cartographic',
        '../../Core/Color',
        '../../Core/ColorGeometryInstanceAttribute',
        '../../Core/defaultValue',
        '../../Core/defined',
        '../../Core/defineProperties',
        '../../Core/DeveloperError',
        '../../Core/Ellipsoid',
        '../../Core/EllipsoidGeodesic',
        '../../Core/Event',
        '../../Core/Extent',
        '../../Core/GeometryInstance',
        '../../Core/jsonp',
        '../../Core/JulianDate',
        '../../Core/Math',
        '../../Core/Matrix4',
        '../../Core/SimplePolylineGeometry',
        '../../Core/TimeInterval',
        '../../Scene/Camera',
        '../../Scene/CameraColumbusViewMode',
        '../../Scene/CameraFlightPath',
        '../../Scene/PerInstanceColorAppearance',
        '../../Scene/PerspectiveFrustum',
        '../../Scene/Primitive',
        '../../Scene/SceneMode',
        '../../DynamicScene/ConstantProperty',
        '../../DynamicScene/DynamicClock',
        '../../DynamicScene/DynamicObject',
        '../../DynamicScene/DynamicObjectCollection',
        '../../DynamicScene/DynamicPath',
        '../../DynamicScene/DynamicPoint',
        '../../DynamicScene/SampledPositionProperty',
        '../createCommand',
        '../../ThirdParty/knockout',
        '../../ThirdParty/when'
    ], function(
        Cartesian2,
        Cartesian3,
        Cartographic,
        Color,
        ColorGeometryInstanceAttribute,
        defaultValue,
        defined,
        defineProperties,
        DeveloperError,
        Ellipsoid,
        EllipsoidGeodesic,
        Event,
        Extent,
        GeometryInstance,
        jsonp,
        JulianDate,
        CesiumMath,
        Matrix4,
        SimplePolylineGeometry,
        TimeInterval,
        Camera,
        CameraColumbusViewMode,
        CameraFlightPath,
        PerInstanceColorAppearance,
        PerspectiveFrustum,
        Primitive,
        SceneMode,
        ConstantProperty,
        DynamicClock,
        DynamicObject,
        DynamicObjectCollection,
        DynamicPath,
        DynamicPoint,
        SampledPositionProperty,
        createCommand,
        knockout,
        when) {
    "use strict";

    function NavigationDataSource() {
        this._changedEvent = new Event();
        this._errorEvent = new Event();
        this._objects = new DynamicObjectCollection();
        this._clock = new DynamicClock();
    }

    /**
     * Gets an event that will be raised when non-time-Varying data changes
     * or if the return value of getIsTimeVarying changes.
     * @memberof DataSource
     * @function
     *
     * @returns {Event} The event.
     */
    NavigationDataSource.prototype.getChangedEvent = function() {
        return this._changedEvent;
    };

    /**
     * Gets an event that will be raised if an error is encountered during processing.
     * @memberof DataSource
     * @function
     *
     * @returns {Event} The event.
     */
    NavigationDataSource.prototype.getErrorEvent = function() {
        return this._errorEvent;
    };

    /**
     * Gets the top level clock associated with this data source, or undefined if no clock exists.
     * @memberof DataSource
     * @function
     *
     * @returns {DynamicClock} The clock associated with this data source, or undefined if none exists.
     */
    NavigationDataSource.prototype.getClock = function() {
        return this._clock;
    };

    /**
     * Gets the DynamicObjectCollection generated by this data source.
     * @memberof DataSource
     * @function
     *
     * @returns {DynamicObjectCollection} The collection of objects generated by this data source.
     */
    NavigationDataSource.prototype.getDynamicObjectCollection = function() {
        return this._objects;
    };

    /**
     * Gets a value indicating if the data varies with simulation time.  If the return value of
     * this function changes, the changed event will be raised.
     * @memberof DataSource
     * @function
     *
     * @returns {Boolean} True if the data is varies with simulation time, false otherwise.
     */
    NavigationDataSource.prototype.getIsTimeVarying = function() {
        return true;
    };

    function geocode(viewModel) {
        var promise = jsonp('http://dev.virtualearth.net/REST/v1/Locations', {
            parameters : {
                query : viewModel._searchText,
                key : 'AkMnCOd4RF1U7D7qgdBz3Fk1aJB3rgCCI_DO841suDGxqOg0SMICTE8Ivy5HhAf5'

            },
            callbackParameterName : 'jsonp'
        });

        when(promise, function(result) {
            viewModel._searchText = result.resourceSets[0].resources[0].name;
            var bbox = result.resourceSets[0].resources[0].bbox;
            var south = bbox[0];
            var west = bbox[1];
            var north = bbox[2];
            var east = bbox[3];
            var extent = Extent.fromDegrees(west, south, east, north);

            var position = viewModel._scene.getCamera().controller.getExtentCameraCoordinates(extent);
            var surfaceNormal = viewModel._ellipsoid.geodeticSurfaceNormal(position);

            var description = {
                destination : position,
                duration : viewModel._flightDuration,
                up : Cartesian3.UNIT_Z,
                direction : surfaceNormal.negate()
            };

            var flight = CameraFlightPath.createAnimation(viewModel._scene, description);
            viewModel._scene.getAnimations().add(flight);
        });
    }

    function showDirections(viewModel) {
        var separator = viewModel._searchText.indexOf(' to ');
        var from = viewModel._searchText.substring(0, separator);
        var to = viewModel._searchText.substring(separator + 4);

        var promise = jsonp('http://dev.virtualearth.net/REST/V1/Routes/Driving', {
            parameters : {
                'wp.0' : from,
                'wp.1' : to,
                distanceUnit : 'mi',
                routePathOutput : 'Points',
                key : 'AkMnCOd4RF1U7D7qgdBz3Fk1aJB3rgCCI_DO841suDGxqOg0SMICTE8Ivy5HhAf5'

            },
            callbackParameterName : 'jsonp'
        });

        when(promise, function(result) {

            var coordinates = result.resourceSets[0].resources[0].routePath.line.coordinates;
            var turns = result.resourceSets[0].resources[0].routeLegs[0].itineraryItems;

            var waypoints = [];
            var time = 0.0;

            var i;
            for (i = 0; i < turns.length; ++i) {
                var turn = turns[i];

                var bestDistanceSquared = 99999999.0;
                var closestPointIndex = 0;

                for (var j = 0; j < coordinates.length; ++j) {
                    var offset = new Cartesian2(coordinates[j][1] - turn.maneuverPoint.coordinates[1],
                                                coordinates[j][0] - turn.maneuverPoint.coordinates[0]);
                    var magnitudeSquared = offset.magnitudeSquared();
                    if (magnitudeSquared < bestDistanceSquared) {
                        bestDistanceSquared = magnitudeSquared;
                        closestPointIndex = j;
                    }
                }

                waypoints.push({
                    time : time,
                    closestPointIndex : closestPointIndex,
                    positionCartographic : Cartographic.fromDegrees(coordinates[closestPointIndex][1], coordinates[closestPointIndex][0], 0.0)
                });
                time += turn.travelDuration;
            }

            var dynamicObject = viewModel._navigationDataSource._objects.getOrCreateObject(viewModel._searchText);
            dynamicObject.position = new SampledPositionProperty();
            dynamicObject.point = new DynamicPoint();
            dynamicObject.point.show = new ConstantProperty(true);
            dynamicObject.point.pixelSize = new ConstantProperty(10);
            dynamicObject.path = new DynamicPath();
            dynamicObject.path.show = new ConstantProperty(true);
            dynamicObject.path.color = new ConstantProperty(new Color(0, 0, 255));

            var geodesic = new EllipsoidGeodesic(waypoints[0].positionCartographic, waypoints[1].positionCartographic, viewModel._ellipsoid);

            var initialTime = new JulianDate();
            var nextWaypoint = 1;
            var distanceBetweenWaypoints = geodesic.getSurfaceDistance();

            for (i = 0; i < coordinates.length; ++i) {
                if (i > waypoints[nextWaypoint].closestPointIndex) {
                    ++nextWaypoint;
                    if (nextWaypoint < waypoints.length) {
                        geodesic.setEndPoints(waypoints[nextWaypoint - 1].positionCartographic, waypoints[nextWaypoint].positionCartographic);
                        distanceBetweenWaypoints = geodesic.getSurfaceDistance();
                    }
                }
                var positionCartographic = Cartographic.fromDegrees(coordinates[i][1], coordinates[i][0], 0.0);
                geodesic.setEndPoints(waypoints[nextWaypoint - 1].positionCartographic, positionCartographic);
                var distanceFromLastWaypoint = geodesic.getSurfaceDistance();
                var waypointTime;
                if (nextWaypoint >= waypoints.length) {
                    waypointTime = waypoints[waypoints.length - 1].time;
                } else {
                    waypointTime = CesiumMath.lerp(waypoints[nextWaypoint - 1].time, waypoints[nextWaypoint].time, distanceFromLastWaypoint / distanceBetweenWaypoints);
                }
                dynamicObject.position.addSample(initialTime.addSeconds(waypointTime), viewModel._ellipsoid.cartographicToCartesian(positionCartographic));
            }

            dynamicObject._setAvailability(new TimeInterval(initialTime, initialTime.addSeconds(waypoints[waypoints.length - 1].time)));

            viewModel._navigationDataSource._clock.startTime = initialTime;
            viewModel._navigationDataSource._clock.stopTime = initialTime.addSeconds(waypoints[waypoints.length - 1].time);
            viewModel._navigationDataSource._clock.currentTime = initialTime;
            viewModel._navigationDataSource._clock.multiplier = 10.0;

            viewModel._navigationDataSource._changedEvent.raiseEvent(viewModel._navigationDataSource);
        });
    }

    /**
     * The view model for {@link HomeButton}.
     * @alias HomeButtonViewModel
     * @constructor
     *
     * @param {Scene} scene The scene instance to use.
     * @param {SceneTransitioner} [transitioner] The scene transitioner instance to use.
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to be viewed when in home position.
     * @param {Number} [flightDuration] The duration of the camera flight in milliseconds
     *
     * @exception {DeveloperError} scene is required.
     */
    var GeocodingWidgetViewModel = function(scene, ellipsoid, flightDuration) {
        if (!defined(scene)) {
            throw new DeveloperError('scene is required.');
        }

        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);
        flightDuration = defaultValue(flightDuration, 1500);

        this._scene = scene;
        this._ellipsoid = ellipsoid;
        this._flightDuration = flightDuration;
        this._searchText = '';
        this._resultText = '';
        this._navigationDataSource = new NavigationDataSource();

        var that = this;
        this._searchCommand = createCommand(function() {
            if (that._searchText.indexOf(' to ') >= 0) {
                showDirections(that);
            } else {
                geocode(that);
            }
        });

        this._inputKeypressCommand = createCommand(function(data, event) {
           if (event.which === 13) {
               that._searchCommand();
           }
           return true;
        });

        /**
         * Gets or sets the tooltip.  This property is observable.
         *
         * @type {String}
         */
        this.tooltip = 'View Home';

        knockout.track(this, ['tooltip', '_searchText']);
    };

    defineProperties(GeocodingWidgetViewModel.prototype, {
        searchText : {
            get : function() { return this._searchText; },
            set : function(value) { this._searchText = value; }
        },

        /**
         * Gets the scene transitioner being used by the scene.
         * If a transitioner is assigned, any running morphs will be completed
         * when the home button is pressed.  The transitioner must be using
         * the same Scene instance as the scene property.
         * @memberof HomeButtonViewModel.prototype
         *
         * @type {SceneTransitioner}
         */
        sceneTransitioner : {
            get : function() {
                return this._transitioner;
            }
        },

        /**
         * Gets the scene to control.
         * @memberof HomeButtonViewModel.prototype
         *
         * @type {Scene}
         */
        scene : {
            get : function() {
                return this._scene;
            }
        },

        /**
         * Gets the ellipsoid to be viewed when in home position.
         * @memberof HomeButtonViewModel.prototype
         *
         * @type {Ellipsoid}
         */
        ellipsoid : {
            get : function() {
                return this._ellipsoid;
            }
        },

        /**
         * Gets the Command that is executed when the button is clicked.
         * @memberof HomeButtonViewModel.prototype
         *
         * @type {Command}
         */
        search : {
            get : function() {
                return this._searchCommand;
            }
        },

        inputKeypress : {
            get : function() {
                return this._inputKeypressCommand;
            }
        },

        /**
         * Gets or sets the the duration of the camera flight in milliseconds.
         * A value of zero causes the camera to instantly switch to home view.
         * @memberof HomeButtonViewModel.prototype
         *
         * @type {Number}
         */
        flightDuration : {
            get : function() {
                return this._flightDuration;
            },
            set : function(value) {
                if (value < 0) {
                    throw new DeveloperError('value must be positive.');
                }
                this._flightDuration = value;
            }
        }
    });

    return GeocodingWidgetViewModel;
});
