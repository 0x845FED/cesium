<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="Use Viewer to start building new applications or easily embed Cesium into existing applications.">
    <meta name="cesium-sandcastle-labels" content="Beginner, Showcases">
    <title>Cesium Demo</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script type="text/javascript" src="../../../ThirdParty/requirejs-2.1.20/require.js"></script>
    <script type="text/javascript">
    require.config({
        baseUrl : '../../../Source',
        waitSeconds : 60
    });
    </script>
</head>
<body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
<style>
    @import url(../templates/bucket.css);
</style>
<div id="cesiumContainer" class="fullSize"></div>
<div id="loadingOverlay"><h1>Loading...</h1></div>
<div id="toolbar"></div>
<script id="cesium_sandcastle_script">
function startup(Cesium) {
    'use strict';
//Sandcastle_Begin
    var viewer = new Cesium.Viewer('cesiumContainer');
    var scene = viewer.scene;
    scene.skyBox = undefined;
    scene.sun = undefined;
    scene.moon = undefined;
    scene.globe = undefined;

    //scene.context.throwOnWebGLError = true;

    var height = 5000000.0;
    var heading = 0.0;
    var pitch = 0.0;
    var roll = 0.0;
    var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);

    var origin = Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706, height);
    var modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(origin, hpr);

    //var diffuseEnvMapURL = '../../SampleData/models/EnvMap/rustig_koppie_envDiffuseHDR.dds';
    //var specularEnvMapURL = '../../SampleData/models/EnvMap/rustig_koppie_envSpecularHDR.dds';
    var diffuseEnvMapURL = '../../SampleData/models/EnvMap/gold_roomDiffuseHDR.dds';
    var specularEnvMapURL = '../../SampleData/models/EnvMap/gold_roomSpecularHDR.dds';
    var origEnvMapURL = '../../SampleData/models/EnvMap/gold_roomEnvHDR.dds';
    var modelURL = '../../SampleData/models/Spheres/MetalRoughSpheres.glb';

    var model = scene.primitives.add(Cesium.Model.fromGltf({
        url : modelURL,
        modelMatrix : modelMatrix,
        minimumPixelSize : 128
    }));

    model.readyPromise.then(function(model) {
        var camera = viewer.camera;

        // Zoom to model
        var controller = scene.screenSpaceCameraController;
        var r = 2.0 * Math.max(model.boundingSphere.radius, camera.frustum.near);
        controller.minimumZoomDistance = r * 0.5;

        var center = Cesium.Matrix4.multiplyByPoint(model.modelMatrix, model.boundingSphere.center, new Cesium.Cartesian3());
        var heading = Cesium.Math.toRadians(230.0);
        var pitch = Cesium.Math.toRadians(-20.0);
        camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, r * 2.0));

        loadEnvMap(diffuseEnvMapURL).then(function(cubeMap) {
            model.diffuseIrradiance = cubeMap;
            //viewCubeMap(cubeMap);
        });
        loadEnvMap(specularEnvMapURL).then(function(cubeMap) {
            model.specularEnvironmentMap = cubeMap;
            //viewCubeMap(cubeMap, 2.0);
        });
        loadEnvMap(origEnvMapURL).then(function(cubeMap) {
            viewCubeMap(cubeMap);
        });
    }).otherwise(function(error){
        window.alert(error);
    });

    function loadEnvMap(url) {
        return Cesium.Resource.fetchArrayBuffer({
            url : url
        }).then(function(buffer) {
            var mipLevel = 0;
            var dds = parseDDS(buffer, true);
            var width = dds.mipmaps[mipLevel].width;
            var height = dds.mipmaps[mipLevel].height;
            var mipmapCount = dds.mipmapCount;
            var sources = {
                positiveX : {
                    arrayBufferView : dds.mipmaps[mipLevel].data,
                    width : width,
                    height : height
                },
                negativeX : {
                    arrayBufferView : dds.mipmaps[mipLevel + mipmapCount].data,
                    width : width,
                    height : height
                },
                positiveY : {
                    arrayBufferView : dds.mipmaps[mipLevel + 2 * mipmapCount].data,
                    width : width,
                    height : height
                },
                negativeY : {
                    arrayBufferView : dds.mipmaps[mipLevel + 3 * mipmapCount].data,
                    width : width,
                    height : height
                },
                positiveZ : {
                    arrayBufferView : dds.mipmaps[mipLevel + 4 * mipmapCount].data,
                    width : width,
                    height : height
                },
                negativeZ : {
                    arrayBufferView : dds.mipmaps[mipLevel + 5 * mipmapCount].data,
                    width : width,
                    height : height
                }
            };
            var mipLevels = new Array(mipmapCount - 1);
            for (var i = 0; i < mipmapCount - 1; ++i) {
                mipLevel = i + 1;
                width = dds.mipmaps[mipLevel].width;
                height = dds.mipmaps[mipLevel].height;
                mipLevels[i] = {
                    positiveX : {
                        arrayBufferView : dds.mipmaps[mipLevel].data,
                        width : width,
                        height : height
                    },
                    negativeX : {
                        arrayBufferView : dds.mipmaps[mipLevel + mipmapCount].data,
                        width : width,
                        height : height
                    },
                    positiveY : {
                        arrayBufferView : dds.mipmaps[mipLevel + 2 * mipmapCount].data,
                        width : width,
                        height : height
                    },
                    negativeY : {
                        arrayBufferView : dds.mipmaps[mipLevel + 3 * mipmapCount].data,
                        width : width,
                        height : height
                    },
                    positiveZ : {
                        arrayBufferView : dds.mipmaps[mipLevel + 4 * mipmapCount].data,
                        width : width,
                        height : height
                    },
                    negativeZ : {
                        arrayBufferView : dds.mipmaps[mipLevel + 5 * mipmapCount].data,
                        width : width,
                        height : height
                    }
                };
            }

            return new Cesium.CubeMap({
                context : scene.context,
                source : sources,
                mipLevels : mipLevels,
                pixelDatatype : Cesium.PixelDatatype.FLOAT,
                sampler : new Cesium.Sampler({
                    minificationFilter : Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR
                })
            });
        });
    }

    function viewCubeMap(cubeMap, lod) {
        lod = Cesium.defaultValue(lod, 0.0);
        var boxGeometryInstance = new Cesium.GeometryInstance({
            geometry : Cesium.BoxGeometry.fromDimensions({
                vertexFormat : Cesium.VertexFormat.POSITION_NORMAL_AND_ST,
                dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)
            })
        });

        var customAppearance = {};
        customAppearance.vertexShaderSource =
            'attribute vec3 position3DHigh;\n' +
            'attribute vec3 position3DLow;\n' +
            'attribute vec3 normal;\n' +
            'attribute vec2 st;\n' +
            'attribute float batchId;\n' +
            '\n' +
            'varying vec3 v_positionEC;\n' +
            'varying vec3 v_normalEC;\n' +
            '\n' +
            'void main()\n' +
            '{\n' +
            '    vec4 p = czm_computePosition();\n' +
            '\n' +
            '    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;\n' +
            '    v_normalEC = czm_normal * normal;\n' +
            '\n' +
            '    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n' +
            '}';
        customAppearance.fragmentShaderSource =
            'uniform samplerCube u_cubeMap;\n' +
            'varying vec3 v_positionEC;\n' +
            'varying vec3 v_normalEC;\n' +
            'void main()\n' +
            '{\n' +
            '    vec3 n = normalize((czm_inverseModelView * vec4(v_positionEC, 1.0)).xyz); \n' +
            '    const mat3 yUpToZUp = mat3(-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0); \n' +
            '    n = yUpToZUp * n; \n' + // TODO
            '    vec3 color = textureLod(u_cubeMap, n, float(' + lod + ')).rgb;\n' +
            '    gl_FragColor = vec4(color, 1.0);\n' +
            '}\n';
        customAppearance.isTranslucent = function() {
            return false;
        };
        customAppearance.getRenderState = function() {
            return {
                depthTest : {
                    enabled : true
                }
            };
        };
        customAppearance.getVertexShaderSource = function() {
            return this.vertexShaderSource;
        };
        customAppearance.getFragmentShaderSource = function() {
            return this.fragmentShaderSource;
        };
        customAppearance.material = {
            update : function() {
            },
            _uniforms : {
                u_cubeMap : function() {
                    return cubeMap;
                }
            }
        };
        scene.primitives.add(new Cesium.Primitive({
            geometryInstances : boxGeometryInstance,
            appearance : customAppearance,
            asynchronous : false,
            modelMatrix : modelMatrix
        }));
    }

    // Temporary code to parse DDS files for loading environment maps adapted from threejs:
    //    https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/DDSLoader.js
    function parseDDS(buffer, loadMipmaps) {
        var dds = {mipmaps : [], width : 0, height : 0, format : null, mipmapCount : 1};

        // Adapted from @toji's DDS utils
        // https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js

        // All values and structures referenced from:
        // http://msdn.microsoft.com/en-us/library/bb943991.aspx/

        var DDS_MAGIC = 0x20534444;

        var DDSD_CAPS = 0x1,
            DDSD_HEIGHT = 0x2,
            DDSD_WIDTH = 0x4,
            DDSD_PITCH = 0x8,
            DDSD_PIXELFORMAT = 0x1000,
            DDSD_MIPMAPCOUNT = 0x20000,
            DDSD_LINEARSIZE = 0x80000,
            DDSD_DEPTH = 0x800000;

        var DDSCAPS_COMPLEX = 0x8,
            DDSCAPS_MIPMAP = 0x400000,
            DDSCAPS_TEXTURE = 0x1000;

        var DDSCAPS2_CUBEMAP = 0x200,
            DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
            DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
            DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
            DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
            DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
            DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
            DDSCAPS2_VOLUME = 0x200000;

        var DDPF_ALPHAPIXELS = 0x1,
            DDPF_ALPHA = 0x2,
            DDPF_FOURCC = 0x4,
            DDPF_RGB = 0x40,
            DDPF_YUV = 0x200,
            DDPF_LUMINANCE = 0x20000;

        function fourCCToInt32(value) {
            return value.charCodeAt(0) +
                   (value.charCodeAt(1) << 8) +
                   (value.charCodeAt(2) << 16) +
                   (value.charCodeAt(3) << 24);

        }

        function int32ToFourCC(value) {
            return String.fromCharCode(
                value & 0xff,
                (value >> 8) & 0xff,
                (value >> 16) & 0xff,
                (value >> 24) & 0xff
            );
        }

        function loadARGBMip(buffer, dataOffset, width, height) {
            var dataLength = width * height * 4;
            //var srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);
            //var byteArray = new Uint8Array(dataLength);
            var srcBuffer = new Float32Array(buffer, dataOffset, dataLength);
            var byteArray = new Float32Array(dataLength);
            var dst = 0;
            var src = 0;
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    /*
                    var b = srcBuffer[src];
                    src++;
                    var g = srcBuffer[src];
                    src++;
                    var r = srcBuffer[src];
                    src++;
                    */
                    var r = srcBuffer[src];
                    src++;
                    var g = srcBuffer[src];
                    src++;
                    var b = srcBuffer[src];
                    src++;
                    var a = srcBuffer[src];
                    src++;
                    byteArray[dst] = r;
                    dst++;	//r
                    byteArray[dst] = g;
                    dst++;	//g
                    byteArray[dst] = b;
                    dst++;	//b
                    byteArray[dst] = a;
                    dst++;	//a
                }
            }
            return byteArray;
        }

        var FOURCC_DXT1 = fourCCToInt32("DXT1");
        var FOURCC_DXT3 = fourCCToInt32("DXT3");
        var FOURCC_DXT5 = fourCCToInt32("DXT5");
        var FOURCC_ETC1 = fourCCToInt32("ETC1");

        var headerLengthInt = 31; // The header length in 32 bit ints

        // Offsets into the header array

        var off_magic = 0;

        var off_size = 1;
        var off_flags = 2;
        var off_height = 3;
        var off_width = 4;

        var off_mipmapCount = 7;

        var off_pfFlags = 20;
        var off_pfFourCC = 21;
        var off_RGBBitCount = 22;
        var off_RBitMask = 23;
        var off_GBitMask = 24;
        var off_BBitMask = 25;
        var off_ABitMask = 26;

        var off_caps = 27;
        var off_caps2 = 28;
        var off_caps3 = 29;
        var off_caps4 = 30;

        // Parse header

        var header = new Int32Array(buffer, 0, headerLengthInt);

        if (header[off_magic] !== DDS_MAGIC) {
            console.error('Invalid magic number in DDS header.');
            return dds;
        }

        /*
        if (!header[off_pfFlags] & DDPF_FOURCC) {
            console.error('TUnsupported format, must contain a FourCC code.');
            return dds;
        }
        */

        var blockBytes;
        var fourCC = header[off_pfFourCC];
        var isRGBAUncompressed = false;

        switch (fourCC) {
            case FOURCC_DXT1:
                blockBytes = 8;
                dds.format = Cesium.PixelFormat.RGB_DXT1;
                break;
            case FOURCC_DXT3:
                blockBytes = 16;
                dds.format = Cesium.PixelFormat.RGBA_DXT3;
                break;
            case FOURCC_DXT5:
                blockBytes = 16;
                dds.format = Cesium.PixelFormat.RGBA_DXT5;
                break;
            case FOURCC_ETC1:
                blockBytes = 8;
                dds.format = Cesium.PixelFormat.RGB_ETC1;
                break;
            default:
                //if (header[off_RGBBitCount] === 32
                //    && header[off_RBitMask] & 0xff0000
                //    && header[off_GBitMask] & 0xff00
                //    && header[off_BBitMask] & 0xff
                //    && header[off_ABitMask] & 0xff000000) {

                    isRGBAUncompressed = true;
                    blockBytes = 64;
                    dds.format = Cesium.PixelFormat.RGBA;
                //} else {
                //    console.error('THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC(fourCC));
                //    return dds;
                //}

        }

        dds.mipmapCount = 1;

        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
            dds.mipmapCount = Math.max(1, header[off_mipmapCount]);
        }

        var caps2 = header[off_caps2];
        dds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;
        if (dds.isCubemap && (
            !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) ||
            !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) ||
            !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) ||
            !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) ||
            !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) ||
            !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ)
        )) {
            console.error('Incomplete cubemap faces');
            return dds;
        }

        dds.width = header[off_width];
        dds.height = header[off_height];

        var dataOffset = header[off_size] + 4;

        // Extract mipmaps buffers

        var faces = dds.isCubemap ? 6 : 1;

        for (var face = 0; face < faces; face++) {
            var width = dds.width;
            var height = dds.height;
            for (var i = 0; i < dds.mipmapCount; i++) {
                var byteArray;
                var dataLength;
                if (isRGBAUncompressed) {
                    byteArray = loadARGBMip(buffer, dataOffset, width, height);
                    dataLength = byteArray.byteLength;
                } else {
                    dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
                    byteArray = new Uint8Array(buffer, dataOffset, dataLength);
                }

                var mipmap = {"data" : byteArray, "width" : width, "height" : height};
                dds.mipmaps.push(mipmap);

                dataOffset += dataLength;

                width = Math.max(width >> 1, 1);
                height = Math.max(height >> 1, 1);
            }
        }
        return dds;
    }
//Sandcastle_End
    Sandcastle.finishedLoading();
}
if (typeof Cesium !== 'undefined') {
    startup(Cesium);
} else if (typeof require === 'function') {
    require(['Cesium'], startup);
}
</script>
</body>
</html>
