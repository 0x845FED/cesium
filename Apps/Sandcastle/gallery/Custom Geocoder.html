<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="Attach a custom data source to the geocoder widget.">
    <meta name="cesium-sandcastle-labels" content="Tutorials,Showcases">
    <title>Cesium Demo</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script type="text/javascript" src="../../../ThirdParty/requirejs-2.1.20/require.js"></script>
    <script type="text/javascript">
    require.config({
        baseUrl : '../../../Source',
        waitSeconds : 60
    });
    </script>
</head>
<body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
<style>
    @import url(../templates/bucket.css);
    #toolbar {
        background: rgba(42, 42, 42, 0.8);
        padding: 4px;
        border-radius: 4px;
    }
    #toolbar input {
        vertical-align: middle;
        padding-top: 2px;
        padding-bottom: 2px;
    }
</style>
<div id="cesiumContainer" class="fullSize"></div>
<div id="loadingOverlay"><h1>Loading...</h1></div>
<script id="cesium_sandcastle_script">
function startup(Cesium) {
    'use strict';
//Sandcastle_Begin
/**
 * This class is an example of a custom geocoder, and reverse geocoder. It provides both through the OpenStreetMap Nominatim service.
 * @alias OpenStreetMapNominatimGeocoder
 * @constructor
 */
function OpenStreetMapNominatimGeocoder() {
}

/* *
 * Object for both input and result. Could be in external file to avoid code redundancy 
 */
var geoLocation = {
         latitude: 0.00,
         longitude: 0.00,
         address: 'default address'
}; 
    
/* search: looking for location of address, reverse: looking for address of a location */
var action = {
         search: 'search?',
         reverse: 'reverse?'
     };
        
var endpoint = 'https://nominatim.openstreetmap.org/';

/**
 * The function called to geocode using this geocoder service.
 *
 * @param {String} input The query to be sent to the geocoder service
 * @returns {Promise<GeocoderResult[]>}
 */
OpenStreetMapNominatimGeocoder.prototype.geocode = function (input) {
    var query = 'format=json&q=' + input;
    var requestString = endpoint + query;
    return Cesium.loadJson(requestString)
        .then(function (results) {
            var bboxDegrees;
            return results.map(function (resultObject) {
                bboxDegrees = resultObject.boundingbox;
                return {
                    displayName: resultObject.display_name,
                    destination: Cesium.Rectangle.fromDegrees(
                        bboxDegrees[2],
                        bboxDegrees[0],
                        bboxDegrees[3],
                        bboxDegrees[1]
                    )
                };
            });
        });
};
    
/**
 * The function called to geocode using this geocoder service.
 *
 * @param {String} input The query to be sent to the geocoder service
 * @returns {Promise<GeocoderResult[]>}
 */
function getAddressFromLocation(geoLocation, callback) { 
     var query = 'format=json&lat=' + geoLocation.latitude + '&lon=' + geoLocation.longitude + '&zoom=18&addressdetails=1';
      var requestString = endpoint + action.reverse + query;
      var promise = Cesium.loadJson(requestString);
      promise.then(function(result) {
         console.log(result);
         geoLocation.address = result.display_name;
         setLocationPoint();
      });  
      callback();
}
  
/*********************************************************************
 * Functions below, could be in an external file. 
 * geoLocation object as well. This works locally but not in Sandcastle
 ********************************************************************/
/**
 * Callback to fly the camera to the location chosen for reverse geocoding.
 */
  function onReverseGeocodeCompletion() {
     viewer.camera.flyTo({
             destination: Cesium.Cartesian3.fromDegrees(geoLocation.longitude, geoLocation.latitude, 25000.0)
          });
  }
        
var viewer = new Cesium.Viewer('cesiumContainer', {
    geocoder: new OpenStreetMapNominatimGeocoder()
});
    
/**
 * Listen for the geocode search to be complete, to mark it with a point.
 */
 viewer.geocoder.viewModel.complete.addEventListener(function () {
     if (!viewer.geocoder.viewModel.searchText.empty){        
         setPointForSearchLocation();       
     }
 });

 /**
 * Find the camera position after search, and put a point there.
 */
  function setPointForSearchLocation() {
      
    var camera = this.viewer.camera;
    var ellipsoid = this.viewer.scene.globe.ellipsoid;
    var coordinate = ellipsoid.cartesianToCartographic(camera.position);
    var lat =  Cesium.Math.toDegrees(coordinate.latitude);
    var long = Cesium.Math.toDegrees(coordinate.longitude);
    var announce = 'Latitude: ' + parseFloat(Math.round(lat * 100) / 100).toFixed(4) + '  ,Longitude: ' + parseFloat(Math.round(long * 100) / 100).toFixed(4);     
       var home = viewer.entities.add({
          name : announce,
          // For Cesium fromDegrees, longitude before latitude.
          position : Cesium.Cartesian3.fromDegrees(long, lat),
          point : {
             pixelSize : 15,
             color : Cesium.Color.AQUAMARINE,
             outlineColor : Cesium.Color.BLACK,
             outlineWidth : 2
          }
      });
  }
    
 /**
 * Handler for left click of the mouse on the map, get latitude and longitude, and start reverse geocoding
 */   
  var handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);

  // Catch the mouse click, and convert the location into degrees  
  handler.setInputAction(

  // Translate mouse click into Geographic coordinates
  function (click) {
     var position = viewer.camera.pickEllipsoid(click.position);
     var location = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
     geoLocation.latitude = Cesium.Math.toDegrees(location.latitude);
     geoLocation.longitude = Cesium.Math.toDegrees(location.longitude);
     // Reverse geocode to get the address
     getAddressFromLocation(geoLocation, onReverseGeocodeCompletion);
   },
      Cesium.ScreenSpaceEventType.LEFT_CLICK
   );

 /**
 * Set a point and mark the address at reverse geocoded location.
 */   
  function setLocationPoint() {     
       viewer.entities.add({
        name : 'address location',
        // Reverse the latitude and longitude when calling "fromDegrees"
        position : Cesium.Cartesian3.fromDegrees(geoLocation.longitude, geoLocation.latitude),
        point : {
            pixelSize : 5,
            color : Cesium.Color.RED,
            outlineColor : Cesium.Color.WHITE,
            outlineWidth : 2
        },
        label : {
            text : geoLocation.address,
            font : '14pt monospace',
            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
            outlineWidth : 2,
            verticalOrigin : Cesium.VerticalOrigin.BOTTOM,
            pixelOffset : new Cesium.Cartesian2(0, -9)
        }
      });
    } 
    

//Sandcastle_End
    Sandcastle.finishedLoading();
}
if (typeof Cesium !== "undefined") {
    startup(Cesium);
} else if (typeof require === "function") {
    require(["Cesium"], startup);
}
</script>
</body>
</html>
