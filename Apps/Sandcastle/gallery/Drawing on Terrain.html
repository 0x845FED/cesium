<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="Draw lines and polygons on terrain with mouse clicks.">
    <meta name="cesium-sandcastle-labels" content="Showcases">
    <title>Cesium Demo</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script type="text/javascript" src="../../../ThirdParty/requirejs-2.1.20/require.js"></script>
    <script type="text/javascript">
    require.config({
        baseUrl : '../../../Source',
        waitSeconds : 60
    });
    </script>
</head>
<body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
<style>
    @import url(../templates/bucket.css);

    #viewChanged, #cameraChanged {
        display: none;
        background-color: red;
        color: white;
    }
</style>
<div id="cesiumContainer" class="fullSize"></div>
<div id="loadingOverlay"><h1>Loading...</h1></div>
<div id="toolbar">
    <table class="infoPanel">
        <tbody>
        <tr>
            <td>Left click to add a vertex.</td>
        </tr>
         <tr>
            <td>Right click to start new shape.</td>
        </tr>
        </tbody>
    </table>
</div>
<script id="cesium_sandcastle_script">
function startup(Cesium) {
    'use strict';
//Sandcastle_Begin
var viewer = new Cesium.Viewer('cesiumContainer',  {
    selectionIndicator : false,
    infoBox : false,
    terrainProvider : Cesium.createWorldTerrain()
});
// Create a function to place a point given a world position.
function createPoint(worldPosition) {
    var point = new Cesium.Entity({
        position : worldPosition,
        point : {
            color : Cesium.Color.WHITE,
            pixelSize : 5,
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
        }
    });
    viewer.entities.add(point);
    return point;
}
// On left mouse click, we want to:
// * Start a new shape if one doesn't already exist.
// * Add a vertex to the active shape if one exists.
var activeShapePoints = [];
var activeShape;
var floatingPoint;
var drawingMode = 'line';
var handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
handler.setInputAction(function(event) {
    // We use `viewer.scene.pickPosition` here instead of `viewer.camera.pickEllipsoid` so that
    // we get the correct point when mousing over terrain.
    var earthPosition = viewer.scene.pickPosition(event.position);
    // `earthPosition` will be undefined if our mouse is not over the globe.
    if (Cesium.defined(earthPosition)) {
        // If this is the first point, we need to initialize the shape.
        if (activeShapePoints.length === 0) {
            // This is the point that'll follow the mouse.
            floatingPoint = createPoint(earthPosition);
            // For the first point, we want to push an extra position into our list of vertices
            // this will be a dynamic point that'll be replaced when the mouse moves.
            activeShapePoints.push(earthPosition);
            // We create a callback property for our positions since we want the shape to update
            // in real time as we move the mouse. We make sure to pass `false` to the
            // `CallbackProperty` constructor to mark it as not constant.
            var dynamicPositions = new Cesium.CallbackProperty(function () {
                // This is a work-around since polylines when `clampToGround` is true will
                // crash if you try to draw a zero length line
                if (activeShapePoints.length === 2) {
                    var distance = Cesium.Cartesian3.distance(activeShapePoints[0], activeShapePoints[1]);
                    if (distance === 0) {
                        return [];
                    }
                }
                return activeShapePoints;
            }, false);
            if (drawingMode === 'line') {
                activeShape = viewer.entities.add({
                    polyline : {
                        positions : dynamicPositions,
                        clampToGround : true,
                        width : 3
                    }
                });
            }
            if (drawingMode === 'polygon') {
                activeShape = viewer.entities.add({
                    polygon: {
                        hierarchy: dynamicPositions,
                        outline: true,
                        material: new Cesium.ColorMaterialProperty(Cesium.Color.WHITE.withAlpha(0.7))
                    }
                });
            }
        }
        // Add this point to the list of vertices defining the shape
        activeShapePoints.push(earthPosition);
        // Render a point to mark this vertex
        createPoint(earthPosition);
    }
}, Cesium.ScreenSpaceEventType.LEFT_CLICK);
// On mouse move, if we have an active shape and a valid point, update the list of points
// and since the shape is using `CallbackProperty` property it will automatically update.
handler.setInputAction(function(event) {
    if (Cesium.defined(floatingPoint)) {
        var newPosition = viewer.scene.pickPosition(event.endPosition);
        if (Cesium.defined(newPosition)) {
            floatingPoint.position.setValue(newPosition);
            activeShapePoints.pop();
            activeShapePoints.push(newPosition);
        }
    }
}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
// On right click, terminate active shape and redraw it as a new entity without the `CallbackProperty`.
function terminateShape() {
    activeShapePoints.pop();
    if (drawingMode === 'line') {
        viewer.entities.add({
            polyline : {
                positions : activeShapePoints,
                clampToGround : true,
                width : 3
            }
        });
    }
    if (drawingMode === 'polygon') {
        viewer.entities.add({
            polygon: {
                hierarchy: activeShapePoints,
                outline: true,
                material: new Cesium.ColorMaterialProperty(Cesium.Color.WHITE.withAlpha(0.7))
            }
        });
    }

    viewer.entities.remove(floatingPoint);
    viewer.entities.remove(activeShape);
    floatingPoint = undefined;
    activeShape = undefined;
    activeShapePoints = [];
}
handler.setInputAction(function(event) {
    terminateShape();
}, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

var options = [{
    text : 'Draw Lines',
    onselect : function() {
        terminateShape();
        drawingMode = 'line';
    }
}, {
    text : 'Draw Polygons',
    onselect : function() {
        terminateShape();
        drawingMode = 'polygon';
    }
}];

Sandcastle.addToolbarMenu(options);
// Zoom in to an area with mountains
viewer.camera.lookAt(Cesium.Cartesian3.fromDegrees(-122.2058, 46.1955, 1000.0), new Cesium.Cartesian3(5000.0, 5000.0, 5000.0));
viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);

viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
//Sandcastle_End
    Sandcastle.finishedLoading();
}
if (typeof Cesium !== "undefined") {
    startup(Cesium);
} else if (typeof require === "function") {
    require(["Cesium"], startup);
}
</script>
</body>
</html>
