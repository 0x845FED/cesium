<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">  <!-- Use Chrome Frame in IE -->
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="A simple CZML example showing four satellites in orbit around the Earth, and some ground objects.">
    <meta name="cesium-sandcastle-labels" content="DataSources, Tutorials">
    <title>Cesium Demo</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script type="text/javascript" src="../../../ThirdParty/requirejs-2.1.9/require.js"></script>
    <script type="text/javascript">
    require.config({
        baseUrl : '../../../Source',
        waitSeconds : 60
    });
    </script>
</head>
<body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
<style>
    @import url(../templates/bucket.css);
</style>
<div id="cesiumContainer" class="fullSize"></div>
<div id="loadingOverlay"><h1>Loading...</h1></div>
<div id="toolbar"></div>
<script id="cesium_sandcastle_script">
function startup(Cesium) {
    "use strict";
//Sandcastle_Begin
/**
 * A {@link DataSource} which loads JSON data formatted for {@link https://github.com/dataarts/webgl-globe|WebGL Globe}.
 * @alias WebGLGlobeDataSource
 * @constructor
 *
 * @param {String} [name] The name of this data source.  If undefined, a name will be taken from
 *                        the name of the file.
 *
 * @example
 * var dataSource = new Cesium.WebGLGlobeDataSource();
 * dataSource.loadUrl('sample.json');
 * viewer.dataSources.add(dataSource);
 */
var WebGLGlobeDataSource = function(name) {
    this._name = name;
    this._changed = new Cesium.Event();
    this._error = new Cesium.Event();
    this._isLoading = false;
    this._loading = new Cesium.Event();
    this._entityCollection = new Cesium.EntityCollection();
    this._seriesNames = [];
    this._seriesToDisplay = undefined;

    /**
     * Gets or sets the function used to compute line color.
     * @type {WebGLGlobeDataSource~ColorFunction}
     */
    this.colorFunction = function(height) {
        return Cesium.Color.fromHsl((0.6 - (height * 0.5)), 1.0, 0.5);
    };

    /**
     * Gets or sets the scale factor applied to the height of each line.
     * @type {Number}
     */
    this.heightScale = 10000000;
};

Object.defineProperties(WebGLGlobeDataSource.prototype, {
    /**
     * Gets a human-readable name for this instance.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {String}
     */
    name : {
        get : function() {
            return this._name;
        }
    },
    /**
     * Since WebGL Globe JSON is not time-dynamic, this property is always undefined.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {DataSourceClock}
     */
    clock : {
        value : undefined,
        writable : false
    },
    /**
     * Gets the collection of {@link Entity} instances.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {EntityCollection}
     */
    entities : {
        get : function() {
            return this._entityCollection;
        }
    },
    /**
     * Gets a value indicating if the data source is currently loading data.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {Boolean}
     */
    isLoading : {
        get : function() {
            return this._isLoading;
        }
    },
    /**
     * Gets an event that will be raised when the underlying data changes.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {Event}
     */
    changedEvent : {
        get : function() {
            return this._changed;
        }
    },
    /**
     * Gets an event that will be raised if an error is encountered during processing.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {Event}
     */
    errorEvent : {
        get : function() {
            return this._error;
        }
    },
    /**
     * Gets an event that will be raised when the data source either starts or stops loading.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {Event}
     */
    loadingEvent : {
        get : function() {
            return this._loading;
        }
    },
    /**
     * Gets the array of series names.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {String}
     */
    seriesNames : {
        get : function() {
            return this._seriesNames;
        }
    },
    /**
     * Gets or sets the name of the series to display.
     * @memberof WebGLGlobeDataSource.prototype
     * @type {String[]}
     */
    seriesToDisplay : {
        get : function() {
            return this._seriesToDisplay;
        },
        set : function(value) {
            this._seriesToDisplay = value;
            var collection = this._entityCollection;
            var entities = collection.entities;
            collection.suspendEvents();
            for (var i = 0; i < entities.length; i++) {
                var entity = entities[i];
                entity.polyline.show.setValue(value === entity.seriesName);
            }
            collection.resumeEvents();
        }
    }
});

/**
 * Asynchronously loads the GeoJSON at the provided url, replacing any existing data.
 *
 * @param {Object} url The url to be processed.
 *
 * @returns {Promise} a promise that will resolve when the GeoJSON is loaded.
 */
WebGLGlobeDataSource.prototype.loadUrl = function(url) {
    if (!Cesium.defined(url)) {
        throw new Cesium.DeveloperError('url is required.');
    }

    var name = Cesium.getFilenameFromUri(url);

    if (this._name !== name) {
        this._name = name;
        this._changed.raiseEvent(this);
    }

    var dataSource = this;
    return Cesium.when(Cesium.loadJson(url), function(geoJson) {
        return dataSource.load(geoJson, url);
    }).otherwise(function(error) {
        this._setLoading(false);
        dataSource._error.raiseEvent(dataSource, error);
        return Cesium.when.reject(error);
    });
};

/**
 * Asynchronously loads the provided data, replacing any existing data.
 *
 * @param {Object} data The object to be processed.
 * @returns {Promise} a promise that will resolve when the data is loaded.
 *
 * @exception {DeveloperError} Unsupported GeoJSON object type.
 */
WebGLGlobeDataSource.prototype.load = function(data) {
    //>>includeStart('debug', pragmas.debug);
    if (!Cesium.defined(data)) {
        throw new Cesium.DeveloperError('data is required.');
    }
    if (!Cesium.defined(this.colorFunction)) {
        throw new Cesium.DeveloperError('this.colorFunction is required.');
    }
    if (typeof this.heightScale !== 'number') {
        throw new Cesium.DeveloperError('this.heightScale is required.');
    }
    //>>includeEnd('debug');

    this._setLoading(true);
    this._seriesNames.length = 0;
    this._seriesToDisplay = undefined;

    var heightScale = this.heightScale;
    var entities = this._entityCollection;
    entities.suspendEvents();
    entities.removeAll();

    for (var x = 0; x < data.length; x++) {
        var series = data[x];
        var seriesName = series[0];
        var coordinates = series[1];
        this._seriesNames.push(seriesName);

        var show = x === 0;
        if (show) {
            this._seriesToDisplay = seriesName;
        }

        for (var i = 0; i < coordinates.length; i += 3) {
            var latitude = coordinates[i];
            var longitude = coordinates[i + 1];
            var height = coordinates[i + 2];
            var color = this.colorFunction(height);
            var surfacePosition = Cesium.Cartesian3.fromDegrees(longitude, latitude, 0);
            var heightPosition = Cesium.Cartesian3.fromDegrees(longitude, latitude, height * heightScale);

            var polyline = new Cesium.PolylineGraphics();
            polyline.show = new Cesium.ConstantProperty(show);
            polyline.material = Cesium.ColorMaterialProperty.fromColor(color);
            polyline.width = new Cesium.ConstantProperty(2);
            polyline.followSurface = new Cesium.ConstantProperty(false);
            polyline.positions = new Cesium.ConstantProperty([surfacePosition, heightPosition]);

            var entity = new Cesium.Entity(seriesName + ' index ' + i.toString());
            entity.polyline = polyline;
            entity.addProperty('seriesName');
            entity.seriesName = seriesName;
            entities.add(entity);
        }
    }
    entities.resumeEvents();

    this._changed.raiseEvent(this);
    this._setLoading(false);
};

WebGLGlobeDataSource.prototype._setLoading = function(isLoading) {
    if (this._isLoading !== isLoading) {
        this._isLoading = isLoading;
        this._loading.raiseEvent(dataSource, isLoading);
    }
};

function buttonCallback(seriesName) {
    return function() {
        dataSource.seriesToDisplay = seriesName;
    };
}

var dataSource = new WebGLGlobeDataSource();
dataSource.loadUrl('../../SampleData/population909500.json').then(function() {
    for (var i = 0; i < dataSource.seriesNames.length; i++) {
        var seriesName = dataSource.seriesNames[i];
        Sandcastle.addToolbarButton(seriesName, buttonCallback(seriesName));
    }
});

var viewer = new Cesium.Viewer('cesiumContainer');
viewer.dataSources.add(dataSource);
//Sandcastle_End
Sandcastle.finishedLoading();
}
</script>
</body>
</html>
