<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">  <!-- Use Chrome Frame in IE -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="Use Viewer to start building new applications or easily embed Cesium into existing applications.">
    <meta name="cesium-sandcastle-labels" content="Beginner, Showcases">
    <title>Cesium Demo</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script type="text/javascript" src="../../../ThirdParty/requirejs-2.1.9/require.js"></script>
    <script type="text/javascript">
    require.config({
        baseUrl : '../../../Source',
        waitSeconds : 60
    });
    </script>
</head>
<body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
<style>
    @import url(../templates/bucket.css);
    #toolbar button { display: block; }
</style>
<div id="cesiumContainer" class="fullSize"></div>
<div id="loadingOverlay"><h1>Loading...</h1></div>
<div id="toolbar"></div>
<script id="cesium_sandcastle_script">
function startup(Cesium) {
    "use strict";
//Sandcastle_Begin

var viewer = new Cesium.Viewer('cesiumContainer');
var city = viewer.scene.primitives.add(new Cesium.Cesium3DTileset({
    url : 'http://localhost:8002/tilesets/Cambridge',

    // Defaults:
    maximumScreenSpaceError : 16,
    debugShowStatistics : false,
    debugFreezeFrame : false,
    debugShowBox : false,
    debugShowcontentBox : false,
    debugShowBoundingVolume : false,
    debugShowContentsBoundingVolume : false
}));

viewer.scene.screenSpaceCameraController.minimumZoomDistance = 1;
viewer.camera.setView({
    position : Cesium.Cartesian3.fromDegrees(-71.1106, 42.3736, 5000.0)
});

viewer.scene.debugShowFramesPerSecond = true;
//viewer.extend(Cesium.viewerCesiumInspectorMixin);

var canvas = viewer.canvas;
canvas.setAttribute('tabindex', '0'); // needed to put focus on the canvas
canvas.onclick = function() {
    // To get key events
    canvas.focus();
};

var handler = new Cesium.ScreenSpaceEventHandler(canvas);

var flags = {
    // Mouse
    leftDown : false,
    middleDown : false,
    rightDown : false,

    annotate : false
};

handler.setInputAction(function(movement) {
    flags.leftDown = true;
}, Cesium.ScreenSpaceEventType.LEFT_DOWN);

handler.setInputAction(function(movement) {
    flags.middleDown = true;
}, Cesium.ScreenSpaceEventType.MIDDLE_DOWN);

handler.setInputAction(function(movement) {
    flags.rightDown = true;
}, Cesium.ScreenSpaceEventType.RIGHT_DOWN);

handler.setInputAction(function(movement) {
    flags.leftDown = false;
}, Cesium.ScreenSpaceEventType.LEFT_UP);

handler.setInputAction(function(movement) {
    flags.middleDown = false;
}, Cesium.ScreenSpaceEventType.MIDDLE_UP);

handler.setInputAction(function(movement) {
    flags.rightDown = false;
}, Cesium.ScreenSpaceEventType.RIGHT_UP);

document.addEventListener('keyup', function(e) {
    if (e.keyCode === 'W'.charCodeAt(0)) {
        flags.annotate = !flags.annotate;
    }
}, false);

var current = {
    model : undefined,
    originalColor : new Cesium.Color()
};

// Highlight building on mouse over
handler.setInputAction(function(movement) {
    if (flags.leftDown || flags.middleDown || flags.rightDown) {
        // Don't highlight when panning and zooming
        return;
    }

    var pickedBuilding = viewer.scene.pick(movement.endPosition);

    if (Cesium.defined(current.building) && (current.building !== pickedBuilding)) {
        // Restore original color to building that is no longer selected

        // This assignment is nessearcy to work with the set property
        current.building.color = Cesium.Color.clone(current.originalColor, current.building.color);
        current.building = undefined;
    }

    if (Cesium.defined(pickedBuilding) && (pickedBuilding !== current.building)) {
        current.building = pickedBuilding;
        Cesium.Color.clone(pickedBuilding.color, current.originalColor);

        // Highlight newly selected building
        pickedBuilding.color = Cesium.Color.clone(Cesium.Color.YELLOW, pickedBuilding.color);
    }
}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

var annotations = viewer.scene.primitives.add(new Cesium.LabelCollection());

handler.setInputAction(function(movement) {
    var building = current.building;
    if (Cesium.defined(building)) {
        if (building.getProperty('clicked')) {
            console.log('already clicked');
        } else {
            var cc3did = building.getProperty('cc3did');
            var longitude = building.getProperty('longitude');
            var latitude = building.getProperty('latitude');
            
            console.log(cc3did + ': (' + longitude + ', ' + latitude + ')');
            building.setProperty('clicked', true);
        }
    }
}, Cesium.ScreenSpaceEventType.LEFT_CLICK);

handler.setInputAction(function(movement) {
    if (flags.annotate) {
        // Add annotation showing the height at the click location
        annotate(movement);
    } else {
        // When a building is double clicked, zoom to it
        zoom(movement);
    }
}, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);

function annotate(movement) {
    if (Cesium.defined(current.building) && viewer.scene.pickPositionSupported) {
        var cartesian = viewer.scene.pickPosition(movement.position);
// TODO: add Cartographic.fromCartesian to Cesium
        var cartographic = viewer.scene.globe.ellipsoid.cartesianToCartographic(cartesian);
        var height = cartographic.height.toFixed(2) + ' m';

        annotations.add({
            position : cartesian,
            text : height,
            horizontalOrigin : Cesium.HorizontalOrigin.LEFT,
            verticalOrigin : Cesium.VerticalOrigin.BOTTOM,
            eyeOffset : new Cesium.Cartesian3(0.0, 0.0, -1.0)
        });
    }
}

function zoom(movement) {
    if (Cesium.defined(current.building) && viewer.scene.pickPositionSupported) {
        var cartesian = viewer.scene.pickPosition(movement.position);
        var toOldPosition = new Cesium.Cartesian3();
        toOldPosition = Cesium.Cartesian3.subtract(viewer.camera.position, cartesian, toOldPosition);
        toOldPosition = Cesium.Cartesian3.normalize(toOldPosition, toOldPosition);
// TODO: Don't hardcode 15.  Base on distance?
        toOldPosition = Cesium.Cartesian3.multiplyByScalar(toOldPosition, 15.0, toOldPosition);
        var newPosition = new Cesium.Cartesian3();
        newPosition = Cesium.Cartesian3.add(cartesian, toOldPosition, newPosition);

// TODO: need better flights
        viewer.camera.flyTo({
            destination : newPosition,
            orientation : {
                direction : viewer.camera.direction,
                up : viewer.camera.up
            },
            duration : 1.0
        });
    }
}

//When a building is double middle clicked, hide it
handler.setInputAction(function(movement) {
    if (Cesium.defined(current.building)) {
        current.building.show = false;
    }
}, Cesium.ScreenSpaceEventType.MIDDLE_DOUBLE_CLICK);

///////////////////////////////////////////////////////////////////////////////

city.tileReady.addEventListener(function(tile) {
    var content = tile.content;
// TODO: use instanceof or check content type?
// TODO: if this does anything async, e.g., call a REST API, then we need to check
//       if the tile was unloaded before updating it.
// TODO: if this does anything async, it could also set tile.show to false until
//       it is ready so it doesn't flash

    // Does the tile have content?  If it is just used for spatial subdivision, it will not.
    if (Cesium.defined(content)) {
        // Is the tile a Batched 3D Model?
        if (content instanceof Cesium.B3dm3DTileContentProvider) {
            // Does it have a per-model height property?
            if (content.hasProperty('height')) {
	            var length = content.batchSize;
	            for (var i = 0; i < length; ++i) {
	                var building = content.getModel(i);
	                var height = building.getProperty('height');
	                if (height < 10) {
	                    building.color = Cesium.Color.RED;
	                } else if (height < 30) {
	                    building.color = Cesium.Color.BLUE;
	                } else if (height < 70) {
	                    building.color = Cesium.Color.CYAN;
	                } else {
	                    building.color = Cesium.Color.ORANGE;
	                }
	            }
	        }
        }
    }
});

///////////////////////////////////////////////////////////////////////////////

/*
city.loadProgress.addEventListener(function(numberOfPendingRequests, numberProcessing) {
    if ((numberOfPendingRequests === 0) && (numberProcessing === 0)) {
        console.log('Stopped loading');
        return;
    }

    console.log('Loading: requests: ' + numberOfPendingRequests + ', processing: ' + numberProcessing);
});
*/

Sandcastle.addToolbarButton('Stats on/off', function() {
    city.debugShowStatistics = !city.debugShowStatistics;
});

Sandcastle.addToolbarButton('Freeze on/off', function() {
    city.debugFreezeFrame = !city.debugFreezeFrame;
});

Sandcastle.addToolbarButton('Colorize on/off', function() {
    city.debugColorizeTiles = !city.debugColorizeTiles;
});

Sandcastle.addToolbarButton('Box on/off', function() {
    city.debugShowBox = !city.debugShowBox;
});

Sandcastle.addToolbarButton('Contents box on/off', function() {
    city.debugShowcontentBox = !city.debugShowcontentBox;
});

Sandcastle.addToolbarButton('BV on/off', function() {
    city.debugShowBoundingVolume = !city.debugShowBoundingVolume;
});

Sandcastle.addToolbarButton('Contents BV on/off', function() {
    city.debugShowContentsBoundingVolume = !city.debugShowContentsBoundingVolume;
});

Sandcastle.addToolbarButton('SSE++', function() {
    ++city.maximumScreenSpaceError;
    console.log('New max SSE: ' + city.maximumScreenSpaceError);
});

Sandcastle.addToolbarButton('SSE--', function() {
    city.maximumScreenSpaceError = Math.max(city.maximumScreenSpaceError - 1, 0);
    console.log('New max SSE: ' + city.maximumScreenSpaceError);
});

//Sandcastle_End
    Sandcastle.finishedLoading();
}
if (typeof Cesium !== "undefined") {
    startup(Cesium);
} else if (typeof require === "function") {
    require(["Cesium"], startup);
}
</script>
</body>
</html>
