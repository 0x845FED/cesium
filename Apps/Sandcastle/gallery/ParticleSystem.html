<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
    <meta name="description" content="Particle systems.">
    <meta name="cesium-sandcastle-labels" content="Beginner, Showcases">
    <title>Cesium Demo</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script type="text/javascript" src="../../../ThirdParty/requirejs-2.1.20/require.js"></script>

    <script type="text/javascript">
    require.config({
        baseUrl : '../../../Source',
        waitSeconds : 60
    });
    </script>

</head>
<body class="sandcastle-loading" data-sandcastle-bucket="bucket-requirejs.html">
<style>
    @import url(../templates/bucket.css);

    #toolbar {
        background: rgba(42, 42, 42, 0.8);
        padding: 4px;
        border-radius: 4px;
    }
    #toolbar input {
        vertical-align: middle;
        padding-top: 2px;
        padding-bottom: 2px;
    }
    #toolbar .header {
        font-weight: bold;
    }

</style>
<div id="cesiumContainer" class="fullSize"></div>
<div id="loadingOverlay"><h1>Loading...</h1></div>
<div id="toolbar">
    <table><tbody>
    <tr>
        <td>Rate</td>
        <td>
            <input type="range" min="0.0" max="100.0" step="1" data-bind="value: rate, valueUpdate: 'input'">
            <input type="text" size="5" data-bind="value: rate">
        </td>
    </tr>

    <tr>
        <td>Min Life</td>
        <td>
            <input type="range" min="0.1" max="30.0" step="1" data-bind="value: minLife, valueUpdate: 'input'">
            <input type="text" size="5" data-bind="value: minLife">
        </td>
    </tr>

    <tr>
        <td>Max Life</td>
        <td>
            <input type="range" min="0.1" max="30.0" step="1" data-bind="value: maxLife, valueUpdate: 'input'">
            <input type="text" size="5" data-bind="value: maxLife">
        </td>
    </tr>

    <tr>
        <td>Min Speed</td>
        <td>
            <input type="range" min="0.0" max="30.0" step="1" data-bind="value: minSpeed, valueUpdate: 'input'">
            <input type="text" size="5" data-bind="value: minSpeed">
        </td>
    </tr>

    <tr>
        <td>Max Speed</td>
        <td>
            <input type="range" min="0.0" max="30.0" step="1" data-bind="value: maxSpeed, valueUpdate: 'input'">
            <input type="text" size="5" data-bind="value: maxSpeed">
        </td>
    </tr>

    <tr>
        <td>Start Scale</td>
        <td>
            <input type="range" min="0.0" max="10.0" step="1" data-bind="value: startScale, valueUpdate: 'input'">
            <input type="text" size="5" data-bind="value: startScale">
        </td>
    </tr>

    <tr>
        <td>End Scale</td>
        <td>
            <input type="range" min="0.0" max="10.0" step="1" data-bind="value: endScale, valueUpdate: 'input'">
            <input type="text" size="5" data-bind="value: endScale">
        </td>
    </tr>

    <tr>
        <td>Gravity</td>
        <td>
            <input type="range" min="-20.0" max="20.0" step="1" data-bind="value: gravity, valueUpdate: 'input'">
            <input type="text" size="5" data-bind="value: gravity">
        </td>
    </tr>

    <tr>
        <td>Translation </td>
        <td>
            X <input type="text" size="5" data-bind="value: transX">
            Y <input type="text" size="5" data-bind="value: transY">
            Z <input type="text" size="5" data-bind="value: transZ">
        </td>
    </tr>

    <tr>
        <td>Rotation </td>
        <td>
            H <input type="text" size="5" data-bind="value: heading">
            P <input type="text" size="5" data-bind="value: pitch">
            R <input type="text" size="5" data-bind="value: roll">
        </td>
    </tr>







    </tbody></table>
</div>

<script id="cesium_sandcastle_script">
function startup(Cesium) {
    'use strict';
//Sandcastle_Begin
var viewer = new Cesium.Viewer('cesiumContainer');

//Set the random number seed for consistent results.
Cesium.Math.setRandomNumberSeed(3);

//Set bounds of our simulation time
var start = Cesium.JulianDate.fromDate(new Date(2015, 2, 25, 16));
var stop = Cesium.JulianDate.addSeconds(start, 360, new Cesium.JulianDate());

//Make sure viewer is at the desired time.
viewer.clock.startTime = start.clone();
viewer.clock.stopTime = stop.clone();
viewer.clock.currentTime = start.clone();
viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP; //Loop at the end
viewer.clock.multiplier = 1;

//Set timeline to simulation bounds
viewer.timeline.zoomTo(start, stop);


var viewModel = {
    rate: 5.0,
    gravity: 0.0,
    minLife: 1.0,
    maxLife: 1.0,
    minSpeed: 5,
    maxSpeed: 5,
    startScale: 1.0,
    endScale: 4.0,

    transX: 2.5,
    transY: 4.0,
    transZ: 1.0,

    heading: 0.0,
    pitch: 0.0,
    roll: 0.0
};

Cesium.knockout.track(viewModel);
var toolbar = document.getElementById('toolbar');
Cesium.knockout.applyBindings(viewModel, toolbar);

//Generate a random circular pattern with varying heights.
function computeCirclularFlight(lon, lat, radius) {
    var property = new Cesium.SampledPositionProperty();
    for (var i = 0; i <= 360; i += 45) {
        var radians = Cesium.Math.toRadians(i);
        var time = Cesium.JulianDate.addSeconds(start, i, new Cesium.JulianDate());
        var position = Cesium.Cartesian3.fromDegrees(lon + (radius * 1.5 * Math.cos(radians)), lat + (radius * Math.sin(radians)), Cesium.Math.nextRandomNumber() * 500 + 1750);
        property.addSample(time, position);

        //Also create a point for each sample we generate.
        viewer.entities.add({
            position : position,
            point : {
                pixelSize : 8,
                color : Cesium.Color.TRANSPARENT,
                outlineColor : Cesium.Color.YELLOW,
                outlineWidth : 3
            }
        });
    }
    return property;
}

//Compute the entity position property.
/*
var position = computeCirclularFlight(-112.110693, 36.0994841, 0.03);
var entity = viewer.entities.add({

    //Set the entity availability to the same interval as the simulation time.
    availability : new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({
        start : start,
        stop : stop
    })]),

    //Use our computed positions
    position : position,

    //Automatically compute orientation based on position movement.
    orientation : new Cesium.VelocityOrientationProperty(position),

    //Load the Cesium plane model to represent the entity
    model : {
        uri : '../../SampleData/models/CesiumAir/Cesium_Air.gltf',
        minimumPixelSize : 64
    },

    //Show the path as a pink line sampled in 1 second increments.
    path : {
        resolution : 1,
        material : new Cesium.PolylineGlowMaterialProperty({
            glowPower : 0.1,
            color : Cesium.Color.YELLOW
        }),
        width : 10
    }
});
*/

var position = Cesium.Cartesian3.fromDegrees(-112.110693, 36.0994841, 1000);
var entity = viewer.entities.add({

    //Set the entity availability to the same interval as the simulation time.
    availability : new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({
        start : start,
        stop : stop
    })]),

    //Use our computed positions
    position : position,

    //Load the Cesium plane model to represent the entity
    model : {
        uri : '../../SampleData/models/CesiumAir/Cesium_Air.gltf',
        minimumPixelSize : 64
    }
});
viewer.trackedEntity = entity;


var scene = viewer.scene;
scene.debugShowFramesPerSecond = true;

var particleSize = 60.0;

var gravityScratch = new Cesium.Cartesian3();

function applyGravity(p, dt) {
    // We need to compute a local up vector for each particle in geocentric space.
    var position = p.position;

    Cesium.Cartesian3.normalize(position, gravityScratch);
    Cesium.Cartesian3.multiplyByScalar(gravityScratch, viewModel.gravity * dt, gravityScratch);

    p.velocity = Cesium.Cartesian3.add(p.velocity, gravityScratch, p.velocity);
}



// Variables to control the emitter position
var heading = 0.0;
var pitch = 0.0;
var roll = 0.0;

var emitterModelMatrix = new Cesium.Matrix4();

var particles = scene.primitives.add(new Cesium.ParticleSystem({

    image: '../../SampleData/fire.png',

    startColor: Cesium.Color.RED.withAlpha(0.7),
    endColor: Cesium.Color.YELLOW.withAlpha(0.3),

    startScale: viewModel.startScale,
    endScale: viewModel.endScale,

    minLife: viewModel.minLife,
    maxLife: viewModel.maxLife,

    minSpeed: viewModel.minSpeed,
    maxSpeed: viewModel.maxSpeed,

    width: particleSize,
    height: particleSize,

    // Particles per second.
    rate: viewModel.rate,

    bursts: [
        {time: 5.0, min: 300, max: 500},
        {time: 10.0, min: 50, max: 100},
        {time: 15.0, min: 200, max: 300}
    ],

    lifeTime: 16.0,

    emitter: new Cesium.CircleEmitter({
        radius: 0.5
    }),

    emitterModelMatrix: Cesium.Matrix4.fromTranslationRotationScale(
        new Cesium.TranslationRotationScale(
            new Cesium.Cartesian3(viewModel.transX, viewModel.transY, viewModel.transZ),
            Cesium.Quaternion.fromHeadingPitchRoll(Cesium.HeadingPitchRoll.fromDegrees(viewModel.heading, viewModel.pitch, viewModel.roll))
        ),
        emitterModelMatrix
    ),

    forces: [applyGravity]
}));

entity._getModelMatrix(viewer.clock.currentTime, particles.modelMatrix);


viewer.scene.preRender.addEventListener(function(scene, time) {
    // Sync the modelMatrix with the entitys position.
    entity._getModelMatrix(viewer.clock.currentTime, particles.modelMatrix);

    // Account for any changes to the emitter model matrix.
    particles.emitterModelMatrix = Cesium.Matrix4.fromTranslationRotationScale(
        new Cesium.TranslationRotationScale(
            new Cesium.Cartesian3(viewModel.transX, viewModel.transY, viewModel.transZ),
            Cesium.Quaternion.fromHeadingPitchRoll(Cesium.HeadingPitchRoll.fromDegrees(viewModel.heading, viewModel.pitch, viewModel.roll))
        ),
        emitterModelMatrix
    );
});


Cesium.knockout.getObservable(viewModel, 'rate').subscribe(
    function(newValue) {
        particles.rate = parseFloat(newValue);
    }
);

Cesium.knockout.getObservable(viewModel, 'minLife').subscribe(
    function(newValue) {
        particles.minLife = parseFloat(newValue);
    }
);

Cesium.knockout.getObservable(viewModel, 'maxLife').subscribe(
    function(newValue) {
        particles.maxLife = parseFloat(newValue);
    }
);

Cesium.knockout.getObservable(viewModel, 'minSpeed').subscribe(
    function(newValue) {
        particles.minSpeed = parseFloat(newValue);
    }
);

Cesium.knockout.getObservable(viewModel, 'maxSpeed').subscribe(
    function(newValue) {
        particles.maxSpeed = parseFloat(newValue);
    }
);

Cesium.knockout.getObservable(viewModel, 'startScale').subscribe(
    function(newValue) {
        particles.startScale = parseFloat(newValue);
    }
);

Cesium.knockout.getObservable(viewModel, 'endScale').subscribe(
    function(newValue) {
        particles.endScale = parseFloat(newValue);
    }
);





//Sandcastle_End
    Sandcastle.finishedLoading();
}
if (typeof Cesium !== "undefined") {
    startup(Cesium);
} else if (typeof require === "function") {
    require(["Cesium"], startup);
}
</script>

</body>
</html>
